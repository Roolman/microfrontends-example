# Mesto

Фронтенд приложение Mesto, реализованное с использованием микрофронтендов

## Описание решения

Приложение Mesto представляет собой упрощенный сервис для обмена фотографиями (местами)

Оно включает в себя следующий функционал:

- Авторизация и регистрация
- Редактирование данных профиля
- Добавление фотографии
- Просмотр фотографии
- Лайк / дизлайк фотографии
- Удаление фотографии

Сервис имеет следующие технические особенности:

- Технически реализован в виде монолита
- Использует библиотеку react
- Не использует какой-либо фреймворк

А также разбит на следующие роуты:

- `/`: Базовый роут. Ренедрит основую страницу приложения. Закрыт за авторизацией
- `/signin`: Роут страницы авторизации
- `/signup`: Роут страницы регистрации

### Декомпозиция монолита

Предположим перед нами стоит задача распилить монолитный фронтенд на несколько микрофронтендов

Используем стратегию **вертикальной нарезки** на основе DDD. Исходя из функционала сервиса можно выделить следующие доменные области:

- `Активация (activation)`: авторизация; регистрация
- `Пользователи (users)`: работа с данными профиля
- `Карточки (cards)`: работа с карточками фотографий

Визуально разделение на домены выглядит следующим образом

![alt text](/assets/microfrontends.png)

Кроме того, в `активации` входят компоненты `авторизации` и `регистрации`

#### Разделение на микрофронтенды

Итак, исходя из декомпозиции на доменные области, получаем следующие микрофронтенды (МФ):

- `activation`: Предоставляет компоненты страниц `signin` и `signup`, а также компонент `кнопки выхода`
- `users`: Предоставляет компоненты `отображения данных профиля`, а также попапы `изменения профиля` и `автара`
- `cards`: Предоставляет компонент `списка карточек`, а также попапы `добавление картоки` и `просмотр фотографии`
- `host`: Хост-приложение, в задачи которого входит связывание всех МФ, роутинг и отображение компонентов `хэдер` и `футер`

Также часть функционала будет вынесена в шаренные библиотеки:

- `utils`: Утилиты для работы с API и авторизацией
- `ui`: Общие стили и компоненты React
- `events`: Общие события EventBus (об этом далее)

#### Общение между МФ

Для общения между микрофронтендами будем использовать паттерн Pub/Sub с использованием шины событий. Определим необходимые события, разбив их по контекстам

Контекст `user` (события, связанные с пользователем):

- Логаут; `user:logout`
- Успешный логин; `user:login-success`
- Успешная регистрация; `user:register-success`
- Обновление данных юзера; `user:update-data`

Контекст `cards` (события, связанные с карточками фотографии):

- Добавление карточки; `cards:add`

Контекст `popup` (события, связанные с открытием/закрытием попапов):

- Открыть попап добавления карточки места; `popup:open-add-place`
- Открыть попап просмотра фотографи; `popup:open-image`
- Открыть попап изменения аватара; `popup:edit-avatar`
- Открыть попап изменения данных профиля; `popup:edit-profile`
- Закрыть все попапы; `popup:close-all`
- Показать тултип; `popup:tooltip-show`

#### Инструменты

Для реализации микрофронтедов будем использовать `Module Federation`. Каждый из МФ будет представлять собой отдельное приложение на базе React фреймворка `Next.JS`. Сам проект будет реализован в рамках `монорепо` с использованием `yarn workspaces`. Такое решение имеет следующие преимущества:

- Использование встроенных возможностей фреймворка
- Использование возможностей `Module Federation`
- Использование SSR для генерации html разметки на сервере
- Хост приложение тоже будет реализована на `Next.JS`, что позволяет легко настроить роутинг между МФ
- Легко использовать шаренные локальные библиотеки в монорепо

#### Итоговая схема

![alt text](/assets/mfs.png)

### Планирование изменений

Поскольку в решении используется монорепо, то разделим директории следующим образом

- Все МФ находятся в директории `apps`
- Все шаренные библиотеки в директории `packages`

Каждое из приложений в `apps` имеет схожую структуру и соответсвует структуре приложения [`Next.JS`](https://nextjs.org/docs/getting-started/project-structure)

#### Подключение МФ в хост

Различие заключается в `next.config.mjs`. В хост приложении с использованием библиотеки `@module-federation/nextjs-mf` указываем МФ (remotes)

```js
const remotes = (isServer) => {
  const location = isServer ? "ssr" : "chunks";
  return {
    cards: `cards@${CARDS_APP_URL}/_next/static/${location}/remoteEntry.js`,
    activation: `activation@${ACTIVATION_APP_URL}/_next/static/${location}/remoteEntry.js`,
    users: `users@${USERS_APP_URL}/_next/static/${location}/remoteEntry.js`,
  };
};
```

В зависимости от среды выполнения (ssr - node / client - browser) указываем url до другого МФ. По этому url в хост приложение будет подключаться модуль МФ.

Пример подключения МФ активации и компонента страницы `singin` в хост

`src/pages/singin`

```ts
// Импортируем компонент страницы - здесь идет запрос по адресу localhost:3002/_next/static/(ssr|chunks)/remoteEntry.js
import SignInPage, {
  getServerSideProps as SignInPageGetServerSideProps,
} from "activation/signin";
const SignIn = SignInPage;
// Опционально - если страница использует SSR, то этот код предварительно выполнится на сервере хоста для отображения данных в html разметке
export const getServerSideProps = SignInPageGetServerSideProps;
// Делаем реэкспорт страницы
export default SignIn;
```

#### Подключение шаренных библиотек

Шаренные библиотеки из папки packages подключаем следующим образом

AddPlacePopup.tsx

```tsx
import { PopupWithForm } from '@mf-example/ui/components/PopupWithForm'

///
    <PopupWithForm>
    { Код компонента формы }
    </PopupWithForm>
```

#### Пример общения через EventBus

Отправим сообщение об успешном логине из компонента `singin` в `host`

SignIn.tsx

```tsx
import "@trutoo/event-bus";
import { UsersEvents } from "@mf-example/events/users";

function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
  e.preventDefault();

  login(email, password).then(() => {
    eventBus.publish(UsersEvents.LoginSuccess, { email });
  });
}
```

В хостe

```tsx
// При маунте подписываемся на события
useEffect(() => {
  const subs: Subscription[] = [];

  // По событию успешного логина выполняем необходимые действия
  subs.push(
    eventBus.subscribe<{ email: string }>(
      UsersEvents.LoginSuccess,
      ({ payload }) => {
        setIsLoggedIn(true);
        setEmail(payload?.email || "");
        router.push("/");
      }
    )
  );

  return () => {
    // При анмаунте отписываемся
    subs.forEach((sub) => sub.unsubscribe());
  };
}, []);
```

## Запуск и разработка

### Dev режим

- Установите зависимости командой `yarn install`
- Выполните команду `yarn dev`
- Дождитесь запуска и перейдите по адресу `localhost:3000`

### Prod режим

- Выполните команду `yarn start`
- Дождитесь билда проектов и запуска приложений
- Перейдите по адресу `localhost:3000`
