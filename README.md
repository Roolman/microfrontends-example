Перейти к [заданию 1](#задание-1)

Перейти к [заданию 2](#задание-2)

# Задание 1

Фронтенд приложение Mesto, реализованное с использованием микрофронтендов

## Описание решения

Приложение Mesto представляет собой упрощенный сервис для обмена фотографиями (местами)

Оно включает в себя следующий функционал:

- Авторизация и регистрация
- Редактирование данных профиля
- Добавление фотографии
- Просмотр фотографии
- Лайк / дизлайк фотографии
- Удаление фотографии

Сервис имеет следующие технические особенности:

- Технически реализован в виде монолита
- Использует библиотеку react
- Не использует какой-либо фреймворк

А также разбит на следующие роуты:

- `/`: Базовый роут. Ренедрит основую страницу приложения. Закрыт за авторизацией
- `/signin`: Роут страницы авторизации
- `/signup`: Роут страницы регистрации

### Декомпозиция монолита

Предположим перед нами стоит задача распилить монолитный фронтенд на несколько микрофронтендов

Используем стратегию **вертикальной нарезки** на основе DDD. Исходя из функционала сервиса можно выделить следующие доменные области:

- `Активация (activation)`: авторизация; регистрация
- `Пользователи (users)`: работа с данными профиля
- `Карточки (cards)`: работа с карточками фотографий

Визуально разделение на домены выглядит следующим образом

![alt text](/assets/microfrontends.png)

Кроме того, в `активации` входят компоненты `авторизации` и `регистрации`

#### Разделение на микрофронтенды

Итак, исходя из декомпозиции на доменные области, получаем следующие микрофронтенды (МФ):

- `activation`: Предоставляет компоненты страниц `signin` и `signup`, а также компонент `кнопки выхода`
- `users`: Предоставляет компоненты `отображения данных профиля`, а также попапы `изменения профиля` и `автара`
- `cards`: Предоставляет компонент `списка карточек`, а также попапы `добавление картоки` и `просмотр фотографии`
- `host`: Хост-приложение, в задачи которого входит связывание всех МФ, роутинг и отображение компонентов `хэдер` и `футер`

Также часть функционала будет вынесена в шаренные библиотеки:

- `utils`: Утилиты для работы с API и авторизацией
- `ui`: Общие стили и компоненты React
- `events`: Общие события EventBus (об этом далее)

#### Общение между МФ

Для общения между микрофронтендами будем использовать паттерн Pub/Sub с использованием шины событий. Определим необходимые события, разбив их по контекстам

Контекст `user` (события, связанные с пользователем):

- Логаут; `user:logout`
- Успешный логин; `user:login-success`
- Успешная регистрация; `user:register-success`
- Обновление данных юзера; `user:update-data`

Контекст `cards` (события, связанные с карточками фотографии):

- Добавление карточки; `cards:add`

Контекст `popup` (события, связанные с открытием/закрытием попапов):

- Открыть попап добавления карточки места; `popup:open-add-place`
- Открыть попап просмотра фотографи; `popup:open-image`
- Открыть попап изменения аватара; `popup:edit-avatar`
- Открыть попап изменения данных профиля; `popup:edit-profile`
- Закрыть все попапы; `popup:close-all`
- Показать тултип; `popup:tooltip-show`

#### Инструменты

Для реализации микрофронтедов будем использовать `Module Federation`. Каждый из МФ будет представлять собой отдельное приложение на базе React фреймворка `Next.JS`. Сам проект будет реализован в рамках `монорепо` с использованием `yarn workspaces`. Такое решение имеет следующие преимущества:

- Использование встроенных возможностей фреймворка
- Использование возможностей `Module Federation`
- Использование SSR для генерации html разметки на сервере
- Хост приложение тоже будет реализована на `Next.JS`, что позволяет легко настроить роутинг между МФ
- Легко использовать шаренные локальные библиотеки в монорепо

#### Итоговая схема

![alt text](/assets/mfs.png)

### Планирование изменений

Поскольку в решении используется монорепо, то разделим директории следующим образом

- Все МФ находятся в директории `apps`
- Все шаренные библиотеки в директории `packages`

Каждое из приложений в `apps` имеет схожую структуру и соответсвует структуре приложения [`Next.JS`](https://nextjs.org/docs/getting-started/project-structure)

#### Подключение МФ в хост

Различие заключается в `next.config.mjs`. В хост приложении с использованием библиотеки `@module-federation/nextjs-mf` указываем МФ (remotes)

```js
const remotes = (isServer) => {
  const location = isServer ? "ssr" : "chunks";
  return {
    cards: `cards@${CARDS_APP_URL}/_next/static/${location}/remoteEntry.js`,
    activation: `activation@${ACTIVATION_APP_URL}/_next/static/${location}/remoteEntry.js`,
    users: `users@${USERS_APP_URL}/_next/static/${location}/remoteEntry.js`,
  };
};
```

В зависимости от среды выполнения (ssr - node / client - browser) указываем url до другого МФ. По этому url в хост приложение будет подключаться модуль МФ.

Пример подключения МФ активации и компонента страницы `singin` в хост

`src/pages/singin`

```ts
// Импортируем компонент страницы - здесь идет запрос по адресу localhost:3002/_next/static/(ssr|chunks)/remoteEntry.js
import SignInPage, {
  getServerSideProps as SignInPageGetServerSideProps,
} from "activation/signin";
const SignIn = SignInPage;
// Опционально - если страница использует SSR, то этот код предварительно выполнится на сервере хоста для отображения данных в html разметке
export const getServerSideProps = SignInPageGetServerSideProps;
// Делаем реэкспорт страницы
export default SignIn;
```

#### Подключение шаренных библиотек

Шаренные библиотеки из папки packages подключаем следующим образом

AddPlacePopup.tsx

```tsx
import { PopupWithForm } from '@mf-example/ui/components/PopupWithForm'

///
    <PopupWithForm>
    { Код компонента формы }
    </PopupWithForm>
```

#### Пример общения через EventBus

Отправим сообщение об успешном логине из компонента `singin` в `host`

SignIn.tsx

```tsx
import "@trutoo/event-bus";
import { UsersEvents } from "@mf-example/events/users";

function handleSubmit(e: React.FormEvent<HTMLFormElement>) {
  e.preventDefault();

  login(email, password).then(() => {
    eventBus.publish(UsersEvents.LoginSuccess, { email });
  });
}
```

В хостe

```tsx
// При маунте подписываемся на события
useEffect(() => {
  const subs: Subscription[] = [];

  // По событию успешного логина выполняем необходимые действия
  subs.push(
    eventBus.subscribe<{ email: string }>(
      UsersEvents.LoginSuccess,
      ({ payload }) => {
        setIsLoggedIn(true);
        setEmail(payload?.email || "");
        router.push("/");
      }
    )
  );

  return () => {
    // При анмаунте отписываемся
    subs.forEach((sub) => sub.unsubscribe());
  };
}, []);
```

## Запуск и разработка

### Dev режим

- Установите зависимости командой `yarn install`
- Выполните команду `yarn dev`
- Дождитесь запуска и перейдите по адресу `localhost:3000`

### Prod режим

- Выполните команду `yarn start`
- Дождитесь билда проектов и запуска приложений
- Перейдите по адресу `localhost:3000`

# Задание 2

Декомпозиция веб-приложения на Django на микросервисы

## Описание решения

Стоит задача декомпозировать веб-приложение торговой площадки

На схеме отображено состояние TO BE, описана краткая реализация необходимых сервисов, а также 2 примера реализации сценариев общения между сервисами

[Ссылка на схему решения в draw.io](https://drive.google.com/file/d/11ZpAr-VIg8m6V34A4Y7oqra9nCK49LFP/view?usp=sharing)

Опишем что мы знаем о приложении

### Приложение AS IS

- Монолитный фронтенд
- Монолитный бэкенд
- 1 база данных PostgreSQL

#### Возможности бэкенд

- Регистрация и авторизация; ролевая модель (клиент, администратор, тех поддержка); валидация токена
- Услуги в профиле пользователя (с ролью клиент); поиск по услугам (для обычных юзеров); CRUD
- Товары в профиле пользователя; CRUD
- Заказы (на товары и услуги): CRUD
- Аукционы на товары (CRUD) + управление аукционом
- Платежная система / Транзакции
- Апелляции
- Нотификации
- Тех поддержка (заявки)
- Отчеты (активность пользователей + статистика заказов + отчет по продажам) - через API, без UI

#### Возможности фронтенд

- Авторизация/регистрация
- Редактирование профиля
- Добавление товара/услуги
- Создание аукциона
- Поиск по товарам и услугам
- Размещение заказа (на товар или услугу)
- Подача заявки на аукцион
- Отображение нотификаций

(предположительно можно)

- Оплата заказа и/или аукциона
- Подача апелляции
- Обращение в тех поддержку
- Формирование отчетов
- Управление заявками и аукционами
- Обработка заявок тех поддержки

### Приложение TO BE

#### Домены

Применим **DDD** для разбивки монолита на микросервисы. Выделим следующие доменные зоны:

- Авторизация
- Пользователи
- Услуги и Товары
- Аукционы
- Заказы
- Поиск
- Нотификации
- Оплата/Транзакции
- Апелляции/споры
- Отчеты
- Аналитика
- Техподдержка

#### Сервисы

Для упрощения предположим, что в каждой доменной зоне соответсвует один микросервис (в реальности их может быть больше). Помимо микросервисов в доменных зонах также понабодятся дополнительные сервисы:

- API Gateway (для обнаружения сервисов, балансировки и мониторинга)
- Event Bus (для организации общения между сервисами)
- Оркестратор саг (для обеспечения согласованности данных сервисов в рамках сложных транзакций)
- Портал backoffice (для простого доступа администратора и тех поддержки к данным сервисов)

#### Таблица всех сервисов

Составим полную таблицу сервисов с их функциональностью и описанием

| Название          | Функционал                                                                                                                                                                 | БД                                                                            | Взаимодействие с другими сервисами                                                                                                                                                                                                                                              | Особенности                                                                                                                                                                                                                                                                            |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Авторизация       | - Генерация токена (например JWT) по логину и паролю клиента; токен подписывается приватным ключом; в токене зашифрованы id пользователя и подпись <br> - Валидация токена | Нет                                                                           | - Используется через API Gateway для авторизации и аутентификации запросов                                                                                                                                                                                                      | - Только этот сервис знает о приватном ключе и хранит его у себя                                                                                                                                                                                                                       |
| Пользователи      | - CRUD по пользователям <br> - Управление ролями                                                                                                                           | PostgreSQL <br> - Данные юзера <br> - Данные ролей                            | - Другие сервисы хранят user_id для связки данных сервиса с данными пользователя. Общение через шину <br> - Отправляет уведомление о новом юзере (в шину)                                                                                                                       | - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                                                                                                               |
| Услуги и товары   | - CRUD по услугам <br> - CRUD по товарам                                                                                                                                   | PostgreSQL <br> - Данные услуг <br> - Данные товаров                          | - Другие сервисы используют id услуги или id товара для получения данных. Общение через шину <br> - Также предоставляет интерфейс для общения через gRPC (для сервиса поиска)                                                                                                   | - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                                                                                                               |
| Аукционы          | - CRUD по аукциону <br> - Управление аукционом (статус; ставки) <br> - Отправка сообщений в сервис Нотификаций при изменениях статуса аукциона / ставки аукциона           | PostgreSQL <br> - Данные аукционов <br> - Данные статуса <br> - Данные ставок | - Отправляет сообщения в сервис Нотификаций через шину при изменениях статуса аукциона / ставки аукциона <br> - Другие сервисы используют id аукциона для получения данных. Общение через шину <br> - Также предоставляет интерфейс для общения через gRPC (для сервиса поиска) | - Заявку на аукцион одобряет Администратор <br> - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                                                               |
| Заказы            | - CRUD по заказам <br> - Управление статусом заказа <br> - Редактирование состава заказа (удаление / добавление товаров и услуг)                                           | PostgreSQL <br> - Данные заказов <br> - Данные статусов                       | - Отправляет сообщения в сервис Нотификаций через шину при изменениях заказа <br> - Другие сервисы используют id заказа для получения данных. Общение через шину                                                                                                                | - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                                                                                                               |
| Поиск             | - Поиск товаров, услуг, аукционов <br> - Фильтрация и сортировка результатов поиска                                                                                        | В зависимости от функционала поиска. Может использовать Redis                 | - Использует данные из сервисов Услуги и Товары; Аукционы для поисковой выдачи. Общение через gRPC                                                                                                                                                                              | - Может использовать кэширование (Redis) для ускорения поисковой выдачи <br> - Может использовать / реализовывать поисковый движок (прим. elasticsearch) <br> - Может использовать балансировку нагрузки <br> - Использует публичный ключ для извлечения id пользователя из JWT токена |
| Нотификации       | - CRUD по нотификациям <br> - Обработка, планирование и отправка нотификаций пользователям по разным каналам связи                                                         | PostgreSQL <br> - Данные нотификаций                                          | Принимает сообщения от других сервисов через шину; создает нотификации; планирует и отправляет нотификации пользователям                                                                                                                                                        | - Может использоваться в будущем для осуществления массовых рассылок пользователям <br> - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                       |
| Апелляции         | - CRUD по апелляциям <br> - Управление статусом аппеляции                                                                                                                  | PostgreSQL <br> - Данные апелляции                                            | Нет                                                                                                                                                                                                                                                                             | - Использует публичный ключ для извлечения id пользователя из JWT токена <br> - Только пользователем с ролью Администратор может редактировать апелляцию                                                                                                                               |
| Платежи           | - CRUD по платежным операциям <br> - CRUD по платежным транзакциям <br> - Управление статусами операции и транзакции                                                       | PostgreSQL <br> - Данные операции <br> - Данные транзакции                    | - Принимает сообщения от других сервисов и отправляет сообщения через шину; <br> - Обращается ко внешним сервисам биллинга для проведения платежной операции                                                                                                                    | - Использует публичный ключ для извлечения id пользователя из JWT токена                                                                                                                                                                                                               |
| Отчеты            | - CRUD по отчетам <br> - Управление статусом отчета                                                                                                                        | PostgreSQL <br> - Данные отчета <br> - Данные файла отчета [Опционально]      | - Обращается к другим сервисам за данными через шину                                                                                                                                                                                                                            | - Может использовать S3 для хранения файлов отчета <br> - Может использовать внутреннюю очередь сообщений для изменения статусов отчета асинхронно (Kafka / RabbitMQ) <br> - Использует публичный ключ для извлечения id пользователя из JWT токена                                    |
| Аналитика         | - Сбор, хранение и обработка данных аналитики <br> - Предоставление возможности выгрузки данных аналитики <br> - Подготовка данных для отображения статистики              | Необходима БД для хранения данных аналитики (например Clickhouse)             | Нет                                                                                                                                                                                                                                                                             | - Может использоваться как часть инфраструктуры по работе с аналитикой                                                                                                                                                                                                                 |
| Тех поддержка     | - CRUD по заявкам <br> - Управление статусом заявки                                                                                                                        | Необходима БД для хранения и управления заявками                              | Нет                                                                                                                                                                                                                                                                             | - Может использовать внешнюю систему управления заявками (HelpDesk, JivoChat)                                                                                                                                                                                                          |
| API Gateway       | - Обнаружение сервисов <br> - Балансировка <br> - Мониторинг                                                                                                               | Нет                                                                           | На схеме                                                                                                                                                                                                                                                                        | - Использует NGINX                                                                                                                                                                                                                                                                     |
| Шина событий      | - Организации общения между сервисами                                                                                                                                      | Нет                                                                           | На схеме                                                                                                                                                                                                                                                                        | - Использует Kafka                                                                                                                                                                                                                                                                     |
| Оркестратор саг   | - Обеспечение согласованности данных сервисов в рамках сложных транзакций                                                                                                  | PostgreSQL <br> - Данные саг                                                  | На схеме                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                        |
| Портал backoffice | - Удобный доступ для администраторов и тех поддержки к данным сервисов                                                                                                     | Нет                                                                           | На схеме                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                        |

#### Сценарии

Приведем в пример 2 сценария организации работы между сервисами

##### Операция регистрации

[На схеме](https://drive.google.com/file/d/11ZpAr-VIg8m6V34A4Y7oqra9nCK49LFP/view?usp=sharing)

1. Начало регистрации — пользователь инициирует регистрацию через API сервиса пользователей. Пользователь передает логин и пароль

2. Запрос JWT токена — сервис пользователей валидирует данные; сервис пользователей создает пользователя в БД и присваивает ему ID. Сервис пользователей отправляет запрос в сервис авторизации через шину на генерацию JWT токена с данными пользователя

3. Ответ JWT токена — сервис авторизации с приватным ключом шифрования генерирует JWT токен (в нем зашифрован ID пользователя) и отсылает его сервису пользователей.

4. Подтверждение регистрации — сервис пользователей принимает JWT токен и отправляет пользователю ответ об успешном прохождении регистрации с данными пользователя и его JWT токеном.

##### Операция оплаты заказа

[На схеме](https://drive.google.com/file/d/11ZpAr-VIg8m6V34A4Y7oqra9nCK49LFP/view?usp=sharing)

1. Переход в оплату — пользователь инициирует перевод заказа в статус "Подготовка к оплате" через API сервиса заказов

2. Инициировать платёж — сервис заказов инициирует сагу оплаты и отправляет сообщение в шину о переводе заказа в статус "На оплату". Сервис оркестратор саг сохраняет данные саги и отправляет сообщение в шину о необходимости инициировать платеж. Сервис платежей принимает сообщение из шины и инициирует платёж, отправив необходимые данные (ID счета пользователя, ID заказа, сумма заказа) во внешний платёжный сервис.

3. Предоставить статус платежа — платёжный сервис принял запрос на проведение оплаты, подтвердил возможность проведения платежа со счёта клиента, назначил идентификатор для этой транзакции и установил статус.

4. Подтверждение платежа — сервис платежей отправляет информацию в шину об успешном подтверждении заказа. Сервис оркестратор переводит сагу в новый статус и уведомляет через шину сервис заказов об успешном подтверждении платежа. Сервис заказов принимает сообщение из шины и переводит статус заказа в "На оплату". Сервис заказов отправляет уведомление об изменении статуса заказа.

5. Инициировать платежную транзакцию — пользователь инициирует начало платежной транзакции через API сервиса заказов. Сервис заказов переводит статус заказа в "В оплате" и отправляет об этом уведомление в шину. Сервис оркестратор фиксирует изменение статуса саги. Сервис платежей принимает сообщение из шины и инициирует транзакцию на проведение оплаты. Внешний сервис платежей подтвердил возможность проведения платежа со счёта клиента, назначил идентификатор для этой транзакции и установил статус.

6. Подтверждение платежной транзакции — сервис платежей отправляет запрос во внешний платёжный сервис для получения текущего статуса обработки транзакции по ID. В случае успешной транзакции сервис платежей отправляет сообщение в шину событий об успешно проведенной транзакции. Сервис оркестратор принимает сообщение и меняет статус саги. Сервис заказов принимает сообщение и изменяет статус заказа на "Оплачено". Сервис заказов отправляет нотификацию об изменении статуса заказа

7. Подтверждение отмены платежной транзакции (альтернативный сценарий) — внешний платёжный сервис уведомляет систему об успешной отмене платежа, предоставляя статус отменённой транзакции. Cервис платежей отправляет сообщение в шину событий об отмене транзакции. Сервис оркестратор принимает сообщение и меняет статус саги. Сервис заказов принимает сообщение и изменяет статус заказа. Сервис заказов отправляет нотификацию об изменении статуса заказа.

#### 14 факторов проектирования

Помимо вышеперечисленно для соответствия 14 факторам проектирования могут быть внедрены следующие технологи

- k8s для организации лучших практик CI/CD; развертывания и масштабируемости сервисов
- Prometheus, Grafana, Elastic Stack для мониторинга и логирования

### Приложение в процессе миграции на микросервисы

Стоит упомянуть, что в ходе миграции на микросервисы может понадобиться

- Anti Corruption Layer для обеспечения согласованности и целостности данных в процессе миграции
- Использование паттерна Strangler Fig для постепенной миграции сервисов

Первыми сервисами для миграции на МС были бы

- Сервис авторизации
- Сервис пользователи
- API Gateway
- ACL (временно)

Этого было бы достаточно, чтобы

- Реализовать минимальный функционал для авторизации и работы с данными пользователя
- Поддержать целостность данных между монолитом и МС
- Протестировать и внедрить новые инструменты (в том числе мониторинг)
